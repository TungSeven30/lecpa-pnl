---
phase: 02-upload-parse
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - frontend/src/services/csvParser.ts
  - frontend/src/services/csvSanitizer.ts
  - frontend/src/services/columnDetector.ts
  - frontend/src/services/amountNormalizer.ts
  - frontend/src/services/dateParser.ts
  - frontend/src/services/bankConfigs.ts
  - frontend/package.json
autonomous: true

must_haves:
  truths:
    - "CSV files can be parsed with headers and proper handling of quoted fields"
    - "CSV injection attacks are prevented by sanitizing dangerous characters"
    - "Date, description, amount, and memo columns are auto-detected from headers"
    - "Amounts are normalized to cents with bank-specific sign conventions"
    - "Multiple date formats are supported (MM/DD/YYYY, YYYY-MM-DD, etc.)"
  artifacts:
    - path: "frontend/src/services/csvParser.ts"
      provides: "PapaParse wrapper for CSV parsing"
      exports: ["parseCSV"]
    - path: "frontend/src/services/csvSanitizer.ts"
      provides: "CSV injection prevention"
      exports: ["sanitizeCSVField"]
    - path: "frontend/src/services/columnDetector.ts"
      provides: "Column auto-detection"
      exports: ["detectColumns", "ColumnMapping"]
    - path: "frontend/src/services/amountNormalizer.ts"
      provides: "Bank-specific amount normalization"
      exports: ["normalizeAmount", "parseAmount"]
    - path: "frontend/src/services/dateParser.ts"
      provides: "Multi-format date parsing"
      exports: ["parseTransactionDate"]
    - path: "frontend/src/services/bankConfigs.ts"
      provides: "Bank configuration definitions"
      exports: ["BANK_CONFIGS", "BankConfig", "BankType"]
  key_links:
    - from: "csvParser.ts"
      to: "csvSanitizer.ts"
      via: "transform callback"
      pattern: "sanitizeCSVField"
    - from: "amountNormalizer.ts"
      to: "bankConfigs.ts"
      via: "bank config lookup"
      pattern: "BANK_CONFIGS"
---

<objective>
Create frontend services for CSV parsing, sanitization, column detection, and amount normalization.

Purpose: Before uploading transactions to the server, the frontend must parse CSV files, sanitize for injection attacks (SEC-06), auto-detect columns (UPLD-02), and normalize amounts with bank-specific rules (UPLD-05, UPLD-07). These services enable client-side processing per SEC-07 (no raw CSV storage).

Output: Six service modules providing complete CSV processing pipeline ready for UI components.
</objective>

<execution_context>
@/Users/tungmbp1423/.claude/get-shit-done/workflows/execute-plan.md
@/Users/tungmbp1423/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/02-upload-parse/02-RESEARCH.md

Research provides code patterns for:
- PapaParse configuration
- OWASP CSV injection sanitization
- Column detection heuristics
- Bank-specific normalization rules
- Day.js date parsing
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install frontend dependencies and create bank configs</name>
  <files>frontend/package.json, frontend/src/services/bankConfigs.ts</files>
  <action>
**Step 1: Install dependencies**
```bash
cd /Users/tungmbp1423/Projects/lecpa-pnl-c/frontend
npm install papaparse react-dropzone dayjs
npm install --save-dev @types/papaparse
```

**Step 2: Create bankConfigs.ts**

Define bank configuration types and constants:

```typescript
// Bank type enum matching backend schema
export type BankType = 'chase' | 'bankofamerica' | 'wellsfargo' | 'capitalone' | 'amex';
export type AccountType = 'checking' | 'credit';

export interface BankConfig {
  name: string;
  // How to interpret amount signs
  // 'negative_is_expense': debits are negative (e.g., Chase)
  // 'positive_is_expense': debits are positive (e.g., BofA, Amex)
  amountNormalization: 'negative_is_expense' | 'positive_is_expense';
  // Expected date formats in order of preference
  dateFormats: string[];
  // Column header patterns for auto-detection
  columns: {
    date: RegExp;
    description: RegExp;
    amount: RegExp;
    memo?: RegExp;
  };
}

export const BANK_CONFIGS: Record<BankType, BankConfig> = {
  chase: {
    name: 'Chase',
    amountNormalization: 'negative_is_expense',
    dateFormats: ['MM/DD/YYYY', 'M/D/YYYY'],
    columns: {
      date: /posting\s*date|trans.*date|date/i,
      description: /description/i,
      amount: /amount/i,
      memo: /memo|detail/i
    }
  },
  bankofamerica: {
    name: 'Bank of America',
    amountNormalization: 'positive_is_expense',
    dateFormats: ['MM/DD/YYYY', 'M/D/YYYY'],
    columns: {
      date: /date|posted/i,
      description: /description|payee/i,
      amount: /amount/i,
      memo: /memo|reference/i
    }
  },
  wellsfargo: {
    name: 'Wells Fargo',
    amountNormalization: 'negative_is_expense',
    dateFormats: ['MM/DD/YYYY', 'M/D/YYYY'],
    columns: {
      date: /date/i,
      description: /description/i,
      amount: /amount/i,
      memo: /memo/i
    }
  },
  capitalone: {
    name: 'Capital One',
    amountNormalization: 'positive_is_expense',
    dateFormats: ['YYYY-MM-DD', 'MM/DD/YYYY'],
    columns: {
      date: /transaction\s*date|posted\s*date|date/i,
      description: /description|merchant/i,
      amount: /amount|debit|credit/i,
      memo: /category|memo/i
    }
  },
  amex: {
    name: 'American Express',
    amountNormalization: 'positive_is_expense',
    dateFormats: ['MM/DD/YYYY', 'M/D/YYYY'],
    columns: {
      date: /date/i,
      description: /description/i,
      amount: /amount/i,
      memo: /extended\s*details|memo/i
    }
  }
};

// Helper to get bank config with fallback
export function getBankConfig(bankType: BankType): BankConfig {
  return BANK_CONFIGS[bankType];
}

// Bank options for UI dropdowns
export const BANK_OPTIONS: Array<{ value: BankType; label: string }> = [
  { value: 'chase', label: 'Chase' },
  { value: 'bankofamerica', label: 'Bank of America' },
  { value: 'wellsfargo', label: 'Wells Fargo' },
  { value: 'capitalone', label: 'Capital One' },
  { value: 'amex', label: 'American Express' }
];

export const ACCOUNT_TYPE_OPTIONS: Array<{ value: AccountType; label: string }> = [
  { value: 'checking', label: 'Checking Account' },
  { value: 'credit', label: 'Credit Card' }
];
```
  </action>
  <verify>
1. `cd /Users/tungmbp1423/Projects/lecpa-pnl-c/frontend && npm list papaparse` - package installed
2. `cd /Users/tungmbp1423/Projects/lecpa-pnl-c/frontend && npm list dayjs` - package installed
3. `ls frontend/src/services/bankConfigs.ts` - file exists
  </verify>
  <done>Dependencies installed and bankConfigs.ts exports BANK_CONFIGS with all 5 bank configurations</done>
</task>

<task type="auto">
  <name>Task 2: Create CSV sanitizer and parser services</name>
  <files>frontend/src/services/csvSanitizer.ts, frontend/src/services/csvParser.ts</files>
  <action>
**Step 1: Create csvSanitizer.ts**

Implement OWASP-recommended CSV injection prevention:

```typescript
/**
 * OWASP CSV Injection Prevention
 * Cells starting with =, +, -, @, \t, \r, \n can be interpreted as formulas
 * when opened in spreadsheets. Prefix with single quote to prevent execution.
 */

const DANGEROUS_CHARS = ['=', '+', '-', '@', '\t', '\r', '\n'];

export function sanitizeCSVField(value: string | null | undefined): string {
  if (value == null) return '';

  const str = String(value).trim();

  // Check if starts with dangerous character
  if (DANGEROUS_CHARS.some(char => str.startsWith(char))) {
    // Exception: negative numbers starting with - are OK
    // Only prefix if it's not a valid number
    if (str.startsWith('-')) {
      const withoutMinus = str.substring(1).replace(/[$,]/g, '');
      if (!isNaN(parseFloat(withoutMinus))) {
        return str; // Valid negative number, don't sanitize
      }
    }
    return `'${str}`;
  }

  return str;
}

/**
 * Sanitize all fields in a row object
 */
export function sanitizeRow<T extends Record<string, unknown>>(row: T): T {
  const sanitized: Record<string, unknown> = {};
  for (const [key, value] of Object.entries(row)) {
    sanitized[sanitizeCSVField(key)] = typeof value === 'string'
      ? sanitizeCSVField(value)
      : value;
  }
  return sanitized as T;
}
```

**Step 2: Create csvParser.ts**

Wrap PapaParse with sanitization:

```typescript
import Papa from 'papaparse';
import { sanitizeCSVField } from './csvSanitizer';

export interface ParsedRow {
  [key: string]: string;
}

export interface ParseResult {
  data: ParsedRow[];
  headers: string[];
  errors: string[];
}

/**
 * Parse CSV file with sanitization
 * Returns Promise with parsed data, headers, and any errors
 */
export function parseCSV(file: File): Promise<ParseResult> {
  return new Promise((resolve, reject) => {
    Papa.parse<ParsedRow>(file, {
      header: true,
      skipEmptyLines: 'greedy',
      dynamicTyping: false, // Keep as strings for validation
      transformHeader: (header: string) => sanitizeCSVField(header),
      transform: (value: string) => sanitizeCSVField(value),
      complete: (results) => {
        if (results.data.length === 0) {
          reject(new Error('CSV file is empty'));
          return;
        }

        const headers = results.meta.fields || [];
        const errors = results.errors.map(e =>
          `Row ${e.row}: ${e.message}`
        );

        resolve({
          data: results.data,
          headers,
          errors
        });
      },
      error: (error) => {
        reject(new Error(`CSV parsing failed: ${error.message}`));
      }
    });
  });
}

/**
 * Get preview of first N rows
 */
export function getPreviewRows(data: ParsedRow[], count: number = 5): ParsedRow[] {
  return data.slice(0, count);
}
```
  </action>
  <verify>Run `cd /Users/tungmbp1423/Projects/lecpa-pnl-c/frontend && npx tsc --noEmit` - should compile without errors</verify>
  <done>csvSanitizer.ts and csvParser.ts exist with correct exports and TypeScript compiles</done>
</task>

<task type="auto">
  <name>Task 3: Create column detector, date parser, and amount normalizer</name>
  <files>frontend/src/services/columnDetector.ts, frontend/src/services/dateParser.ts, frontend/src/services/amountNormalizer.ts</files>
  <action>
**Step 1: Create columnDetector.ts**

```typescript
import dayjs from 'dayjs';
import customParseFormat from 'dayjs/plugin/customParseFormat';
import { BankConfig } from './bankConfigs';

dayjs.extend(customParseFormat);

export interface ColumnMapping {
  date: string | null;
  description: string | null;
  amount: string | null;
  memo: string | null;
}

// Common date formats to try when validating
const VALIDATION_DATE_FORMATS = [
  'MM/DD/YYYY', 'M/D/YYYY',
  'YYYY-MM-DD',
  'DD/MM/YYYY', 'D/M/YYYY',
  'MMM DD, YYYY',
  'MMMM D, YYYY'
];

/**
 * Validate if a value looks like a date
 */
function isValidDate(value: string): boolean {
  if (!value || value.trim() === '') return false;
  return VALIDATION_DATE_FORMATS.some(fmt =>
    dayjs(value, fmt, true).isValid()
  );
}

/**
 * Validate if a value looks like an amount
 */
function isValidAmount(value: string): boolean {
  if (!value || value.trim() === '') return false;
  // Remove currency symbols, commas, parentheses (for negative)
  const cleaned = value.replace(/[$,()]/g, '').trim();
  return !isNaN(parseFloat(cleaned)) && isFinite(parseFloat(cleaned));
}

/**
 * Auto-detect column mapping from headers and first row
 */
export function detectColumns(
  headers: string[],
  firstRow: Record<string, string>,
  bankConfig?: BankConfig
): ColumnMapping {
  const mapping: ColumnMapping = {
    date: null,
    description: null,
    amount: null,
    memo: null
  };

  // Use bank-specific patterns if available, otherwise use generic patterns
  const patterns = bankConfig?.columns || {
    date: /date|posted|trans/i,
    description: /desc|merchant|vendor|payee|name/i,
    amount: /amount|debit|credit/i,
    memo: /memo|note|comment|detail|reference/i
  };

  // Find date column
  mapping.date = headers.find(h => patterns.date.test(h)) || null;

  // Validate with content if found
  if (mapping.date && !isValidDate(firstRow[mapping.date])) {
    // Try other date-like headers
    const altDate = headers.find(h =>
      h !== mapping.date &&
      patterns.date.test(h) &&
      isValidDate(firstRow[h])
    );
    mapping.date = altDate || mapping.date;
  }

  // Find amount column
  mapping.amount = headers.find(h => patterns.amount.test(h)) || null;

  if (mapping.amount && !isValidAmount(firstRow[mapping.amount])) {
    const altAmount = headers.find(h =>
      h !== mapping.amount &&
      patterns.amount.test(h) &&
      isValidAmount(firstRow[h])
    );
    mapping.amount = altAmount || mapping.amount;
  }

  // Find description column
  mapping.description = headers.find(h => patterns.description.test(h)) || null;

  // Find memo column (optional)
  if (patterns.memo) {
    mapping.memo = headers.find(h => patterns.memo!.test(h)) || null;
  }

  return mapping;
}

/**
 * Check if all required columns are mapped
 */
export function hasRequiredMappings(mapping: ColumnMapping): boolean {
  return !!(mapping.date && mapping.description && mapping.amount);
}

/**
 * Get list of missing required columns
 */
export function getMissingColumns(mapping: ColumnMapping): string[] {
  const missing: string[] = [];
  if (!mapping.date) missing.push('Date');
  if (!mapping.description) missing.push('Description');
  if (!mapping.amount) missing.push('Amount');
  return missing;
}
```

**Step 2: Create dateParser.ts**

```typescript
import dayjs from 'dayjs';
import customParseFormat from 'dayjs/plugin/customParseFormat';
import { BankConfig } from './bankConfigs';

dayjs.extend(customParseFormat);

// Fallback formats if bank-specific formats fail
const FALLBACK_DATE_FORMATS = [
  'MM/DD/YYYY', 'M/D/YYYY',
  'YYYY-MM-DD',
  'DD/MM/YYYY', 'D/M/YYYY',
  'MMM DD, YYYY',
  'MMMM D, YYYY',
  'MM-DD-YYYY',
  'YYYY/MM/DD'
];

/**
 * Parse a date string using bank-specific formats with fallback
 * Returns Date object or throws if unparseable
 */
export function parseTransactionDate(
  rawDate: string,
  bankConfig?: BankConfig
): Date {
  const trimmed = rawDate.trim();

  if (!trimmed) {
    throw new Error('Empty date value');
  }

  // Try bank-specific formats first
  if (bankConfig?.dateFormats) {
    for (const format of bankConfig.dateFormats) {
      const parsed = dayjs(trimmed, format, true);
      if (parsed.isValid()) {
        return parsed.toDate();
      }
    }
  }

  // Try fallback formats
  for (const format of FALLBACK_DATE_FORMATS) {
    const parsed = dayjs(trimmed, format, true);
    if (parsed.isValid()) {
      return parsed.toDate();
    }
  }

  // Last resort: let dayjs try to auto-parse
  const autoParsed = dayjs(trimmed);
  if (autoParsed.isValid()) {
    return autoParsed.toDate();
  }

  throw new Error(`Unable to parse date: "${rawDate}"`);
}

/**
 * Check if a date is within a range (inclusive)
 */
export function isDateInRange(
  date: Date,
  startDate: Date,
  endDate: Date
): boolean {
  const d = dayjs(date).startOf('day');
  const start = dayjs(startDate).startOf('day');
  const end = dayjs(endDate).endOf('day');

  return (d.isSame(start) || d.isAfter(start)) &&
         (d.isSame(end) || d.isBefore(end));
}

/**
 * Format date for display
 */
export function formatDate(date: Date): string {
  return dayjs(date).format('MM/DD/YYYY');
}
```

**Step 3: Create amountNormalizer.ts**

```typescript
import { BankConfig, BankType, BANK_CONFIGS } from './bankConfigs';

/**
 * Parse amount string to number
 * Handles: $1,234.56, (500.00), -500.00, 500.00
 */
export function parseAmount(rawAmount: string): number {
  if (!rawAmount || rawAmount.trim() === '') {
    throw new Error('Empty amount value');
  }

  let cleaned = rawAmount.trim();

  // Check for parentheses (accounting notation for negative)
  const isParenthesized = cleaned.startsWith('(') && cleaned.endsWith(')');
  if (isParenthesized) {
    cleaned = cleaned.slice(1, -1);
  }

  // Remove currency symbols and commas
  cleaned = cleaned.replace(/[$,]/g, '');

  const amount = parseFloat(cleaned);

  if (isNaN(amount) || !isFinite(amount)) {
    throw new Error(`Invalid amount: "${rawAmount}"`);
  }

  // Apply parentheses negation
  return isParenthesized ? -amount : amount;
}

/**
 * Normalize amount to standard convention: negative = expense, positive = income
 * Returns amount in cents (integer)
 */
export function normalizeAmount(
  rawAmount: string,
  bankType: BankType
): number {
  const config = BANK_CONFIGS[bankType];
  let amount = parseAmount(rawAmount);

  // Apply bank-specific normalization
  if (config.amountNormalization === 'positive_is_expense') {
    // Bank shows expenses as positive, we need them negative
    amount = -amount;
  }
  // If 'negative_is_expense', amount is already in correct format

  // Convert to cents (integer storage)
  return Math.round(amount * 100);
}

/**
 * Format cents to display string
 */
export function formatAmountFromCents(cents: number): string {
  const dollars = cents / 100;
  return new Intl.NumberFormat('en-US', {
    style: 'currency',
    currency: 'USD'
  }).format(dollars);
}

/**
 * Get sign indicator for amount
 */
export function getAmountSign(cents: number): 'expense' | 'income' {
  return cents < 0 ? 'expense' : 'income';
}
```
  </action>
  <verify>Run `cd /Users/tungmbp1423/Projects/lecpa-pnl-c/frontend && npx tsc --noEmit` - should compile without errors</verify>
  <done>columnDetector.ts, dateParser.ts, and amountNormalizer.ts exist with all exports and TypeScript compiles</done>
</task>

</tasks>

<verification>
After all tasks complete:
1. `cd /Users/tungmbp1423/Projects/lecpa-pnl-c/frontend && npx tsc --noEmit` - TypeScript compiles
2. `ls frontend/src/services/` - all 6 service files exist
3. Dependencies installed: papaparse, react-dropzone, dayjs
</verification>

<success_criteria>
- [ ] papaparse, react-dropzone, dayjs installed in frontend
- [ ] bankConfigs.ts exports BANK_CONFIGS with 5 banks
- [ ] csvSanitizer.ts exports sanitizeCSVField function
- [ ] csvParser.ts exports parseCSV function using PapaParse
- [ ] columnDetector.ts exports detectColumns and ColumnMapping
- [ ] dateParser.ts exports parseTransactionDate with multi-format support
- [ ] amountNormalizer.ts exports normalizeAmount with bank-specific rules
- [ ] All services use TypeScript with proper types
- [ ] TypeScript compiles without errors
</success_criteria>

<output>
After completion, create `.planning/phases/02-upload-parse/02-02-SUMMARY.md`
</output>
