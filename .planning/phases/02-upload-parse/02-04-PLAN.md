---
phase: 02-upload-parse
plan: 04
type: execute
wave: 3
depends_on: [02-03]
files_modified:
  - worker/src/routes/uploads.ts
  - frontend/src/hooks/useUploads.ts
  - frontend/src/pages/ProjectDetail.tsx
autonomous: true

must_haves:
  truths:
    - "Staff can delete an upload and all associated transactions are removed"
    - "Deleted uploads no longer appear in the uploads list"
    - "Delete action requires user confirmation before execution"
  artifacts:
    - path: "worker/src/routes/uploads.ts"
      provides: "DELETE /projects/:id/uploads/:uploadId endpoint"
      contains: "app.delete"
    - path: "frontend/src/hooks/useUploads.ts"
      provides: "useDeleteUpload mutation hook"
      exports: ["useDeleteUpload"]
  key_links:
    - from: "ProjectDetail.tsx"
      to: "useDeleteUpload"
      via: "mutation call"
      pattern: "useDeleteUpload"
---

<objective>
Add ability to delete uploads and their associated transactions (UPLD-06).

Purpose: Staff may upload wrong files or need to re-import data. This plan adds soft delete for uploads with cascade to transactions, plus frontend confirmation UI.

Output: Working delete functionality with API endpoint and UI confirmation.
</objective>

<execution_context>
@/Users/tungmbp1423/.claude/get-shit-done/workflows/execute-plan.md
@/Users/tungmbp1423/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md

Dependencies from prior plans:
@.planning/phases/02-upload-parse/02-01-SUMMARY.md (schema with soft delete columns)
@.planning/phases/02-upload-parse/02-03-SUMMARY.md (upload API and UI)

Existing code to extend:
@worker/src/routes/uploads.ts
@frontend/src/hooks/useUploads.ts
@frontend/src/pages/ProjectDetail.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add DELETE endpoint for uploads with transaction cascade</name>
  <files>worker/src/routes/uploads.ts</files>
  <action>
Add DELETE endpoint to worker/src/routes/uploads.ts:

```typescript
// DELETE /projects/:projectId/uploads/:uploadId - Soft delete upload and transactions
app.delete('/:uploadId', async (c) => {
  const projectId = parseInt(c.req.param('projectId'));
  const uploadId = parseInt(c.req.param('uploadId'));
  const userId = c.get('userId');
  const db = c.get('db');

  // Verify project belongs to user
  const [project] = await db
    .select()
    .from(projects)
    .where(and(
      eq(projects.id, projectId),
      eq(projects.userId, userId)
    ))
    .limit(1);

  if (!project) {
    return c.json({ error: 'Project not found' }, 404);
  }

  // Verify upload exists and belongs to project
  const [upload] = await db
    .select()
    .from(uploads)
    .where(and(
      eq(uploads.id, uploadId),
      eq(uploads.projectId, projectId),
      eq(uploads.status, 'active')
    ))
    .limit(1);

  if (!upload) {
    return c.json({ error: 'Upload not found' }, 404);
  }

  const now = new Date();

  // Soft delete: set status to deleted and deletedAt timestamp
  await db
    .update(uploads)
    .set({
      status: 'deleted',
      deletedAt: now
    })
    .where(eq(uploads.id, uploadId));

  // Also soft delete associated transactions by marking their upload as deleted
  // Transactions don't have their own deletedAt, they're filtered by upload status
  // Alternatively, we could add a deletedAt to transactions schema - but per schema
  // we rely on upload status for now.

  // Note: For a hard delete, you would use:
  // await db.delete(transactions).where(eq(transactions.uploadId, uploadId));
  // await db.delete(uploads).where(eq(uploads.id, uploadId));
  // But we prefer soft delete for audit trail per project decisions.

  return c.json({ success: true, deletedAt: now.toISOString() });
});
```

Also update the GET list endpoint to filter out deleted uploads (if not already filtering by status='active').

Make sure the required imports are present at the top of the file.
  </action>
  <verify>Run `cd /Users/tungmbp1423/Projects/lecpa-pnl-c/worker && npx tsc --noEmit` - should compile without errors</verify>
  <done>DELETE endpoint exists at /projects/:projectId/uploads/:uploadId, soft deletes upload by setting status and deletedAt</done>
</task>

<task type="auto">
  <name>Task 2: Add useDeleteUpload hook and delete UI to ProjectDetail</name>
  <files>frontend/src/hooks/useUploads.ts, frontend/src/pages/ProjectDetail.tsx</files>
  <action>
**Step 1: Add useDeleteUpload to frontend/src/hooks/useUploads.ts**

```typescript
export function useDeleteUpload(projectId: number) {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: async (uploadId: number) => {
      const response = await apiFetch(`/api/projects/${projectId}/uploads/${uploadId}`, {
        method: 'DELETE'
      });

      if (!response.ok) {
        const error = await response.json();
        throw new Error(error.error || 'Failed to delete upload');
      }

      return response.json();
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['uploads', projectId] });
    }
  });
}
```

**Step 2: Add delete functionality to ProjectDetail.tsx**

Add the delete hook and state:
```typescript
const deleteUpload = useDeleteUpload(projectId);
const [deletingUploadId, setDeletingUploadId] = useState<number | null>(null);
```

Add delete handler:
```typescript
const handleDeleteUpload = async (uploadId: number) => {
  if (!confirm('Are you sure you want to delete this upload? All associated transactions will be removed.')) {
    return;
  }

  setDeletingUploadId(uploadId);
  try {
    await deleteUpload.mutateAsync(uploadId);
  } catch (err) {
    alert(err instanceof Error ? err.message : 'Failed to delete upload');
  } finally {
    setDeletingUploadId(null);
  }
};
```

Update the uploads list rendering to include delete button:
```typescript
{uploads.map(upload => (
  <div key={upload.id} className="py-3 flex items-center justify-between">
    <div>
      <p className="font-medium text-gray-900">{upload.filename}</p>
      <p className="text-sm text-gray-500">
        {upload.bankType} • {upload.accountType} • {upload.transactionCount} transactions
      </p>
    </div>
    <div className="flex items-center space-x-4">
      <span className="text-sm text-gray-400">
        {new Date(upload.createdAt).toLocaleDateString()}
      </span>
      <button
        onClick={() => handleDeleteUpload(upload.id)}
        disabled={deletingUploadId === upload.id}
        className="text-red-600 hover:text-red-800 text-sm disabled:opacity-50"
      >
        {deletingUploadId === upload.id ? 'Deleting...' : 'Delete'}
      </button>
    </div>
  </div>
))}
```
  </action>
  <verify>Run `cd /Users/tungmbp1423/Projects/lecpa-pnl-c/frontend && npx tsc --noEmit` - should compile without errors</verify>
  <done>useDeleteUpload hook added, ProjectDetail shows delete button with confirmation for each upload</done>
</task>

</tasks>

<verification>
After all tasks complete:
1. `cd /Users/tungmbp1423/Projects/lecpa-pnl-c/worker && npx tsc --noEmit` - Worker TypeScript compiles
2. `cd /Users/tungmbp1423/Projects/lecpa-pnl-c/frontend && npx tsc --noEmit` - Frontend TypeScript compiles
3. `grep -l "app.delete" worker/src/routes/uploads.ts` - DELETE endpoint exists
4. `grep -l "useDeleteUpload" frontend/src/hooks/useUploads.ts` - Hook exported
5. `grep -l "handleDeleteUpload" frontend/src/pages/ProjectDetail.tsx` - Delete handler in page
</verification>

<success_criteria>
- [ ] DELETE /api/projects/:id/uploads/:uploadId endpoint exists
- [ ] Endpoint soft deletes upload by setting status='deleted' and deletedAt
- [ ] Endpoint verifies project ownership before deletion
- [ ] useDeleteUpload hook invalidates uploads query on success
- [ ] ProjectDetail shows Delete button for each upload
- [ ] Delete requires user confirmation (confirm dialog)
- [ ] Delete button shows loading state while processing
- [ ] TypeScript compiles without errors
</success_criteria>

<output>
After completion, create `.planning/phases/02-upload-parse/02-04-SUMMARY.md`
</output>
