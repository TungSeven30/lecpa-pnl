---
phase: 01-foundation
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - worker/src/routes/auth.ts
  - worker/src/middleware/jwt.ts
  - worker/src/middleware/rateLimit.ts
  - worker/src/utils/email.ts
  - worker/src/index.ts
  - frontend/src/pages/Login.tsx
  - frontend/src/pages/AuthVerify.tsx
  - frontend/src/hooks/useAuth.ts
  - frontend/src/lib/auth-context.tsx
  - frontend/src/App.tsx
autonomous: true
user_setup:
  - service: resend
    why: "Transactional email for magic links"
    env_vars:
      - name: RESEND_API_KEY
        source: "Resend Dashboard -> API Keys -> Create API Key"
    dashboard_config:
      - task: "Verify domain or use onboarding@resend.dev for testing"
        location: "Resend Dashboard -> Domains"

must_haves:
  truths:
    - "User can submit email to request magic link"
    - "Magic link email is sent via Resend API"
    - "Clicking valid magic link logs user in and redirects to dashboard"
    - "Invalid/expired token shows appropriate error"
    - "Session persists in httpOnly cookie for 7 days"
    - "User can log out and cookie is cleared"
    - "Rate limiting blocks excessive magic link requests"
    - "Email delivery failures are logged"
  artifacts:
    - path: "worker/src/routes/auth.ts"
      provides: "Auth endpoints: request-magic-link, verify, logout, me"
      exports: ["default"]
    - path: "worker/src/middleware/jwt.ts"
      provides: "JWT verification middleware"
      exports: ["jwtAuth"]
    - path: "worker/src/middleware/rateLimit.ts"
      provides: "Rate limiting middleware"
      exports: ["rateLimitAuth"]
    - path: "worker/src/utils/email.ts"
      provides: "Resend email helper"
      exports: ["sendMagicLink"]
    - path: "frontend/src/pages/Login.tsx"
      provides: "Magic link request form"
      min_lines: 40
    - path: "frontend/src/pages/AuthVerify.tsx"
      provides: "Token verification page"
      min_lines: 30
  key_links:
    - from: "worker/src/routes/auth.ts"
      to: "worker/src/utils/email.ts"
      via: "sendMagicLink function call"
      pattern: "sendMagicLink"
    - from: "worker/src/routes/auth.ts"
      to: "worker/src/middleware/rateLimit.ts"
      via: "middleware chain"
      pattern: "rateLimitAuth"
    - from: "worker/src/index.ts"
      to: "worker/src/routes/auth.ts"
      via: "app.route('/api/auth', authRoutes)"
      pattern: "app\\.route.*auth"
    - from: "frontend/src/pages/AuthVerify.tsx"
      to: "/api/auth/verify"
      via: "fetch on mount"
      pattern: "fetch.*auth/verify"
---

<objective>
Implement complete magic link authentication system with JWT sessions, rate limiting, and Resend email integration.

Purpose: Enable staff to securely access the application using passwordless authentication. This satisfies AUTH-01 through AUTH-04, SEC-03, SEC-05, EMAIL-01, and EMAIL-03 requirements.

Output: Working authentication flow where users request magic link via email, click to verify, receive JWT session cookie, and can log out.
</objective>

<execution_context>
@/Users/tungmbp1423/.claude/get-shit-done/workflows/execute-plan.md
@/Users/tungmbp1423/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-foundation/01-RESEARCH.md
@.planning/phases/01-foundation/01-01-SUMMARY.md (after Plan 01 completes)

Key patterns from research:
- Magic link two-step verification (GET shows button, POST consumes token) to handle email scanners
- JWT with @tsndr/cloudflare-worker-jwt, throwError: true option
- httpOnly cookie with SameSite=Strict
- Rate limiting via Workers Rate Limiting API binding
- Resend SDK with error handling and logging
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create auth backend routes and middleware</name>
  <files>
    worker/src/routes/auth.ts
    worker/src/middleware/jwt.ts
    worker/src/middleware/rateLimit.ts
    worker/src/utils/email.ts
    worker/src/index.ts
  </files>
  <action>
Create worker/src/middleware/rateLimit.ts:
```typescript
import { createMiddleware } from 'hono/factory';
import type { Env } from '../index';

export const rateLimitAuth = createMiddleware<{ Bindings: Env }>(async (c, next) => {
  const body = await c.req.json().catch(() => ({}));
  const email = body.email || 'unknown';

  // Rate limit by email to prevent abuse
  const { success } = await c.env.RATE_LIMITER.limit({
    key: `magic-link:${email}`
  });

  if (!success) {
    return c.json({ error: 'Too many requests. Please try again later.' }, 429);
  }

  // Re-attach body for downstream handlers (already consumed)
  c.set('parsedBody', body);
  await next();
});
```

Create worker/src/middleware/jwt.ts:
```typescript
import { verify } from '@tsndr/cloudflare-worker-jwt';
import { createMiddleware } from 'hono/factory';
import type { Env } from '../index';

export const jwtAuth = createMiddleware<{ Bindings: Env }>(async (c, next) => {
  const cookie = c.req.header('Cookie');
  const session = cookie?.match(/session=([^;]+)/)?.[1];

  if (!session) {
    return c.json({ error: 'Unauthorized' }, 401);
  }

  try {
    const payload = await verify(session, c.env.JWT_SECRET, {
      throwError: true,
      clockTolerance: 15
    });

    if (!payload.userId) {
      return c.json({ error: 'Invalid token' }, 401);
    }

    c.set('userId', payload.userId as number);
    await next();
  } catch (err) {
    return c.json({ error: 'Invalid or expired token' }, 401);
  }
});
```

Create worker/src/utils/email.ts:
```typescript
import { Resend } from 'resend';

interface SendMagicLinkOptions {
  resendApiKey: string;
  email: string;
  token: string;
  appUrl: string;
}

export async function sendMagicLink(options: SendMagicLinkOptions): Promise<{ success: boolean; error?: string }> {
  const { resendApiKey, email, token, appUrl } = options;
  const resend = new Resend(resendApiKey);

  const verifyUrl = `${appUrl}/auth/verify?token=${token}`;

  try {
    const { data, error } = await resend.emails.send({
      from: 'LeCPA P&L <noreply@yourdomain.com>', // User updates domain
      to: email,
      subject: 'Your login link - LeCPA P&L Generator',
      html: `
        <div style="font-family: sans-serif; max-width: 600px; margin: 0 auto;">
          <h2>Log in to LeCPA P&L Generator</h2>
          <p>Click the button below to log in. This link expires in 15 minutes.</p>
          <a href="${verifyUrl}"
             style="display: inline-block; background: #2563eb; color: white;
                    padding: 12px 24px; text-decoration: none; border-radius: 6px;
                    margin: 16px 0;">
            Log in to your account
          </a>
          <p style="color: #666; font-size: 14px;">
            If you didn't request this link, you can safely ignore this email.
          </p>
          <p style="color: #999; font-size: 12px;">
            Link: ${verifyUrl}
          </p>
        </div>
      `
    });

    if (error) {
      console.error('Resend error:', JSON.stringify(error));
      return { success: false, error: error.message };
    }

    console.log('Magic link email sent:', { to: email, id: data?.id });
    return { success: true };
  } catch (err) {
    const message = err instanceof Error ? err.message : 'Unknown error';
    console.error('Email send failed:', message);
    return { success: false, error: message };
  }
}
```

Create worker/src/routes/auth.ts:
```typescript
import { Hono } from 'hono';
import { sign } from '@tsndr/cloudflare-worker-jwt';
import { eq, and, isNull, gt } from 'drizzle-orm';
import { z } from 'zod';
import type { Env } from '../index';
import { createDb } from '../db/client';
import { users, magicLinks } from '../db/schema';
import { sendMagicLink } from '../utils/email';
import { rateLimitAuth } from '../middleware/rateLimit';
import { jwtAuth } from '../middleware/jwt';

const app = new Hono<{ Bindings: Env; Variables: { userId: number; parsedBody: any } }>();

const requestMagicLinkSchema = z.object({
  email: z.string().email('Invalid email address')
});

// POST /api/auth/request-magic-link - Request a magic link
app.post('/request-magic-link', rateLimitAuth, async (c) => {
  const body = c.get('parsedBody') || await c.req.json();

  const parsed = requestMagicLinkSchema.safeParse(body);
  if (!parsed.success) {
    return c.json({ error: parsed.error.issues[0].message }, 400);
  }

  const { email } = parsed.data;
  const db = createDb(c.env.DB);

  // Find or create user
  let user = await db.select().from(users).where(eq(users.email, email)).get();

  if (!user) {
    const result = await db.insert(users).values({
      email,
      createdAt: new Date()
    }).returning().get();
    user = result;
  }

  // Generate token
  const token = crypto.randomUUID();
  const expiresAt = new Date(Date.now() + 15 * 60 * 1000); // 15 minutes

  await db.insert(magicLinks).values({
    userId: user.id,
    token,
    expiresAt
  });

  // Send email
  const emailResult = await sendMagicLink({
    resendApiKey: c.env.RESEND_API_KEY,
    email,
    token,
    appUrl: c.env.APP_URL
  });

  if (!emailResult.success) {
    console.error('Magic link email failed:', { email, error: emailResult.error });
    // Still return success to prevent email enumeration, but log the failure
  }

  return c.json({ success: true, message: 'If an account exists, a login link has been sent.' });
});

// GET /api/auth/verify - Verify magic link token (shows confirmation page)
app.get('/verify', async (c) => {
  const token = c.req.query('token');

  if (!token) {
    return c.json({ error: 'Token required' }, 400);
  }

  const db = createDb(c.env.DB);

  // Check if token is valid (not used, not expired)
  const link = await db.select()
    .from(magicLinks)
    .where(and(
      eq(magicLinks.token, token),
      isNull(magicLinks.usedAt),
      gt(magicLinks.expiresAt, new Date())
    ))
    .get();

  if (!link) {
    return c.json({ valid: false, error: 'Invalid or expired token' });
  }

  return c.json({ valid: true });
});

// POST /api/auth/verify - Consume token and create session
app.post('/verify', async (c) => {
  const { token } = await c.req.json();

  if (!token) {
    return c.json({ error: 'Token required' }, 400);
  }

  const db = createDb(c.env.DB);

  // Find and validate token
  const link = await db.select()
    .from(magicLinks)
    .where(and(
      eq(magicLinks.token, token),
      isNull(magicLinks.usedAt),
      gt(magicLinks.expiresAt, new Date())
    ))
    .get();

  if (!link) {
    return c.json({ error: 'Invalid or expired token' }, 400);
  }

  // Mark as used (single-use)
  await db.update(magicLinks)
    .set({ usedAt: new Date() })
    .where(eq(magicLinks.id, link.id));

  // Update user's last login
  await db.update(users)
    .set({ lastLogin: new Date() })
    .where(eq(users.id, link.userId));

  // Get user for response
  const user = await db.select().from(users).where(eq(users.id, link.userId)).get();

  // Create JWT (7 days)
  const payload = {
    userId: link.userId,
    exp: Math.floor(Date.now() / 1000) + (7 * 24 * 60 * 60)
  };
  const jwt = await sign(payload, c.env.JWT_SECRET);

  // Set httpOnly cookie
  c.header('Set-Cookie',
    `session=${jwt}; HttpOnly; Secure; SameSite=Strict; Max-Age=${7*24*60*60}; Path=/`
  );

  return c.json({
    success: true,
    user: { id: user!.id, email: user!.email, name: user!.name }
  });
});

// POST /api/auth/logout - Clear session
app.post('/logout', async (c) => {
  c.header('Set-Cookie', 'session=; HttpOnly; Secure; SameSite=Strict; Max-Age=0; Path=/');
  return c.json({ success: true });
});

// GET /api/auth/me - Get current user (protected)
app.get('/me', jwtAuth, async (c) => {
  const userId = c.get('userId');
  const db = createDb(c.env.DB);

  const user = await db.select({
    id: users.id,
    email: users.email,
    name: users.name
  }).from(users).where(eq(users.id, userId)).get();

  if (!user) {
    return c.json({ error: 'User not found' }, 404);
  }

  return c.json({ user });
});

export default app;
```

Update worker/src/index.ts:
- Import authRoutes from './routes/auth'
- Mount auth routes: app.route('/api/auth', authRoutes)
- Ensure CORS middleware is before routes
- Export Env type for use in other files
  </action>
  <verify>
    - `cd worker && npx tsc --noEmit` shows no type errors
    - All files exist: routes/auth.ts, middleware/jwt.ts, middleware/rateLimit.ts, utils/email.ts
    - `grep -r "rateLimitAuth" worker/src/routes/auth.ts` shows middleware usage
    - `grep -r "jwtAuth" worker/src/routes/auth.ts` shows protected route
  </verify>
  <done>Auth backend complete with magic link flow, JWT sessions, rate limiting, and Resend integration</done>
</task>

<task type="auto">
  <name>Task 2: Create frontend auth pages and context</name>
  <files>
    frontend/src/pages/Login.tsx
    frontend/src/pages/AuthVerify.tsx
    frontend/src/hooks/useAuth.ts
    frontend/src/lib/auth-context.tsx
    frontend/src/App.tsx
  </files>
  <action>
Create frontend/src/lib/auth-context.tsx:
```typescript
import { createContext, useContext, useState, useEffect, ReactNode } from 'react';
import { apiFetch } from './api';

interface User {
  id: number;
  email: string;
  name: string | null;
}

interface AuthContextType {
  user: User | null;
  loading: boolean;
  login: (user: User) => void;
  logout: () => Promise<void>;
  checkAuth: () => Promise<void>;
}

const AuthContext = createContext<AuthContextType | null>(null);

export function AuthProvider({ children }: { children: ReactNode }) {
  const [user, setUser] = useState<User | null>(null);
  const [loading, setLoading] = useState(true);

  const checkAuth = async () => {
    try {
      const data = await apiFetch<{ user: User }>('/auth/me');
      setUser(data.user);
    } catch {
      setUser(null);
    } finally {
      setLoading(false);
    }
  };

  const login = (user: User) => {
    setUser(user);
  };

  const logout = async () => {
    await apiFetch('/auth/logout', { method: 'POST' });
    setUser(null);
  };

  useEffect(() => {
    checkAuth();
  }, []);

  return (
    <AuthContext.Provider value={{ user, loading, login, logout, checkAuth }}>
      {children}
    </AuthContext.Provider>
  );
}

export function useAuth() {
  const context = useContext(AuthContext);
  if (!context) {
    throw new Error('useAuth must be used within AuthProvider');
  }
  return context;
}
```

Create frontend/src/hooks/useAuth.ts (re-export from context):
```typescript
export { useAuth } from '../lib/auth-context';
```

Create frontend/src/pages/Login.tsx:
```typescript
import { useState } from 'react';
import { useForm } from 'react-hook-form';
import { zodResolver } from '@hookform/resolvers/zod';
import { z } from 'zod';
import { apiFetch } from '../lib/api';

const loginSchema = z.object({
  email: z.string().email('Please enter a valid email')
});

type LoginForm = z.infer<typeof loginSchema>;

export function Login() {
  const [submitted, setSubmitted] = useState(false);
  const [error, setError] = useState<string | null>(null);

  const { register, handleSubmit, formState: { errors, isSubmitting } } = useForm<LoginForm>({
    resolver: zodResolver(loginSchema)
  });

  const onSubmit = async (data: LoginForm) => {
    setError(null);
    try {
      await apiFetch('/auth/request-magic-link', {
        method: 'POST',
        body: JSON.stringify(data)
      });
      setSubmitted(true);
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Failed to send login link');
    }
  };

  if (submitted) {
    return (
      <div style={{ maxWidth: 400, margin: '100px auto', padding: 20, textAlign: 'center' }}>
        <h1>Check your email</h1>
        <p>We sent a login link to your email address. Click the link to log in.</p>
        <p style={{ color: '#666', fontSize: 14 }}>The link expires in 15 minutes.</p>
      </div>
    );
  }

  return (
    <div style={{ maxWidth: 400, margin: '100px auto', padding: 20 }}>
      <h1>Log in to LeCPA P&L</h1>
      <p style={{ color: '#666' }}>Enter your email to receive a login link.</p>

      <form onSubmit={handleSubmit(onSubmit)} style={{ marginTop: 20 }}>
        <div style={{ marginBottom: 16 }}>
          <label htmlFor="email" style={{ display: 'block', marginBottom: 4 }}>Email</label>
          <input
            id="email"
            type="email"
            {...register('email')}
            style={{ width: '100%', padding: 8, fontSize: 16, border: '1px solid #ccc', borderRadius: 4 }}
            placeholder="you@example.com"
          />
          {errors.email && (
            <p style={{ color: 'red', fontSize: 14, marginTop: 4 }}>{errors.email.message}</p>
          )}
        </div>

        {error && (
          <p style={{ color: 'red', marginBottom: 16 }}>{error}</p>
        )}

        <button
          type="submit"
          disabled={isSubmitting}
          style={{
            width: '100%',
            padding: 12,
            fontSize: 16,
            backgroundColor: '#2563eb',
            color: 'white',
            border: 'none',
            borderRadius: 6,
            cursor: isSubmitting ? 'not-allowed' : 'pointer',
            opacity: isSubmitting ? 0.7 : 1
          }}
        >
          {isSubmitting ? 'Sending...' : 'Send login link'}
        </button>
      </form>
    </div>
  );
}
```

Create frontend/src/pages/AuthVerify.tsx:
```typescript
import { useEffect, useState } from 'react';
import { useSearchParams, useNavigate } from 'react-router-dom';
import { apiFetch } from '../lib/api';
import { useAuth } from '../hooks/useAuth';

export function AuthVerify() {
  const [searchParams] = useSearchParams();
  const navigate = useNavigate();
  const { login } = useAuth();
  const [status, setStatus] = useState<'checking' | 'valid' | 'invalid' | 'verifying' | 'error'>('checking');
  const [error, setError] = useState<string | null>(null);

  const token = searchParams.get('token');

  useEffect(() => {
    if (!token) {
      setStatus('invalid');
      setError('No token provided');
      return;
    }

    // Check if token is valid (GET request)
    apiFetch<{ valid: boolean; error?: string }>(`/auth/verify?token=${token}`)
      .then(data => {
        if (data.valid) {
          setStatus('valid');
        } else {
          setStatus('invalid');
          setError(data.error || 'Invalid token');
        }
      })
      .catch(() => {
        setStatus('invalid');
        setError('Failed to verify token');
      });
  }, [token]);

  const handleConfirm = async () => {
    setStatus('verifying');
    try {
      const data = await apiFetch<{ success: boolean; user: { id: number; email: string; name: string | null } }>(
        '/auth/verify',
        { method: 'POST', body: JSON.stringify({ token }) }
      );
      login(data.user);
      navigate('/dashboard');
    } catch (err) {
      setStatus('error');
      setError(err instanceof Error ? err.message : 'Failed to log in');
    }
  };

  if (status === 'checking') {
    return (
      <div style={{ maxWidth: 400, margin: '100px auto', padding: 20, textAlign: 'center' }}>
        <h1>Verifying...</h1>
        <p>Please wait while we verify your login link.</p>
      </div>
    );
  }

  if (status === 'invalid' || status === 'error') {
    return (
      <div style={{ maxWidth: 400, margin: '100px auto', padding: 20, textAlign: 'center' }}>
        <h1>Invalid Link</h1>
        <p style={{ color: '#666' }}>{error || 'This login link is invalid or has expired.'}</p>
        <a href="/login" style={{ color: '#2563eb' }}>Request a new login link</a>
      </div>
    );
  }

  return (
    <div style={{ maxWidth: 400, margin: '100px auto', padding: 20, textAlign: 'center' }}>
      <h1>Confirm Login</h1>
      <p style={{ color: '#666' }}>Click below to complete your login.</p>

      <button
        onClick={handleConfirm}
        disabled={status === 'verifying'}
        style={{
          marginTop: 20,
          padding: '12px 24px',
          fontSize: 16,
          backgroundColor: '#2563eb',
          color: 'white',
          border: 'none',
          borderRadius: 6,
          cursor: status === 'verifying' ? 'not-allowed' : 'pointer',
          opacity: status === 'verifying' ? 0.7 : 1
        }}
      >
        {status === 'verifying' ? 'Logging in...' : 'Log in to my account'}
      </button>
    </div>
  );
}
```

Update frontend/src/App.tsx:
```typescript
import { Routes, Route, Navigate } from 'react-router-dom';
import { AuthProvider, useAuth } from './lib/auth-context';
import { Login } from './pages/Login';
import { AuthVerify } from './pages/AuthVerify';

function ProtectedRoute({ children }: { children: React.ReactNode }) {
  const { user, loading } = useAuth();

  if (loading) {
    return <div style={{ padding: 20 }}>Loading...</div>;
  }

  if (!user) {
    return <Navigate to="/login" replace />;
  }

  return <>{children}</>;
}

function Dashboard() {
  const { user, logout } = useAuth();

  return (
    <div style={{ padding: 20 }}>
      <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: 20 }}>
        <h1>LeCPA P&L Generator</h1>
        <div>
          <span style={{ marginRight: 16 }}>{user?.email}</span>
          <button
            onClick={logout}
            style={{
              padding: '8px 16px',
              backgroundColor: '#f3f4f6',
              border: '1px solid #d1d5db',
              borderRadius: 4,
              cursor: 'pointer'
            }}
          >
            Log out
          </button>
        </div>
      </div>
      <p>Welcome! Projects will appear here.</p>
    </div>
  );
}

function AppRoutes() {
  return (
    <Routes>
      <Route path="/login" element={<Login />} />
      <Route path="/auth/verify" element={<AuthVerify />} />
      <Route path="/dashboard" element={
        <ProtectedRoute>
          <Dashboard />
        </ProtectedRoute>
      } />
      <Route path="/" element={<Navigate to="/dashboard" replace />} />
    </Routes>
  );
}

export default function App() {
  return (
    <AuthProvider>
      <AppRoutes />
    </AuthProvider>
  );
}
```

Update frontend/src/main.tsx to ensure BrowserRouter wraps everything correctly:
```typescript
import React from 'react';
import ReactDOM from 'react-dom/client';
import { BrowserRouter } from 'react-router-dom';
import { QueryClient, QueryClientProvider } from '@tanstack/react-query';
import App from './App';

const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      staleTime: 1000 * 60 * 5,
      retry: 1,
      refetchOnWindowFocus: false
    }
  }
});

ReactDOM.createRoot(document.getElementById('root')!).render(
  <React.StrictMode>
    <QueryClientProvider client={queryClient}>
      <BrowserRouter>
        <App />
      </BrowserRouter>
    </QueryClientProvider>
  </React.StrictMode>
);
```
  </action>
  <verify>
    - `cd frontend && npx tsc --noEmit` shows no type errors
    - All files exist: pages/Login.tsx, pages/AuthVerify.tsx, lib/auth-context.tsx
    - `grep -r "useAuth" frontend/src/App.tsx` shows auth hook usage
    - `grep -r "ProtectedRoute" frontend/src/App.tsx` shows route protection
  </verify>
  <done>Frontend auth flow complete with login page, verification page, auth context, and protected routes</done>
</task>

</tasks>

<verification>
After all tasks complete:

1. **Backend auth endpoints:**
   Start worker: `cd worker && npm run dev`

   Test request magic link:
   ```bash
   curl -X POST http://localhost:8787/api/auth/request-magic-link \
     -H "Content-Type: application/json" \
     -d '{"email":"test@example.com"}'
   ```
   Should return `{"success":true,"message":"If an account exists..."}`.

2. **Rate limiting:**
   Run the same curl 11+ times quickly. Should get 429 after 10 requests.

3. **Full flow test (manual):**
   - Start both: `npm run dev` from root
   - Visit http://localhost:5173/login
   - Enter email, submit
   - Check worker logs for magic link token (or email if Resend configured)
   - Manually navigate to http://localhost:5173/auth/verify?token=TOKEN
   - Click "Log in to my account"
   - Should redirect to /dashboard with user email visible
   - Click "Log out", should return to /login

4. **Protected route:**
   Clear cookies, visit http://localhost:5173/dashboard directly.
   Should redirect to /login.
</verification>

<success_criteria>
1. POST /api/auth/request-magic-link accepts email, returns success
2. Magic link token stored in database with 15-min expiry
3. GET /api/auth/verify?token=X returns valid:true for valid tokens
4. POST /api/auth/verify consumes token, sets httpOnly cookie
5. GET /api/auth/me returns user when authenticated
6. POST /api/auth/logout clears session cookie
7. Rate limiting enforced on magic link requests (10/min)
8. Frontend login flow: email -> check email -> click link -> dashboard
9. Protected routes redirect to login when unauthenticated
10. Logout button works from dashboard
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation/01-02-SUMMARY.md`
</output>
